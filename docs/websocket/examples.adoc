---
title: Examples of the WebSocket API
layout: docs-adoc
---

:page-liquid:

The following requests upsert a collection defining two change streams:

- *all* bound at `/messages/_streams/all`
- *mine* bound at `/messages/_streams/mine`

++++
{% include code-header.html type="Request" %}
++++

[source,http]
PUT /messages HTTP/1.1

++++
{% include code-header.html type="Request body" %}
++++
[source,json]
----
{
    "streams" : [
      { "stages" : [
          {
              "_$match": {
                "_$or" : [ { "operationType": "insert" }, { "operationType": "update" } ]
            }
          }
      ],
        "uri" : "all"
      },
      { "stages" : [
          { "_$match" : { "fullDocument::name" : { "_$var" : "n" } } }
        ],
        "uri" : "mine"
      }
    ]
}
----

Note that the `$match` stage specifies a condition on the `name` property using `fullDocument::name`.
This is because the Change Event looks like:

[source,json]
----
{
    "fullDocument": {
        "_id": { "$oid": "5e15ff5779ca449eb20fdd09" },
        "message": "hi uji, how are you?",
        "name": "uji",
        "_etag": { "$oid": "5e15ff57a2e5700c3459e801" }
    },
    "documentKey": {
        "_id": { "$oid": "5e15ff5779ca449eb20fdd09" }
    },
    "updateDescription": null,
    "operationType": "insert"
}
----

Note between the `_links` collection property the URIs of the
change streams (returned with `?rep=SHAL`).

++++
{% include code-header.html type="Request" %}
++++

[source,http]
GET /messages?rep=SHAL HTTP/1.1

++++
{% include code-header.html type="Response" %}
++++

[source,json]
----
{
    "_links": {
        "all": {
            "href": "/messages/_streams/all"
        },
        "mine": {
            "href": "/messages/_streams/mine"
        }
    }
}
----