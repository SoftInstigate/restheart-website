---
title: Interceptors
layout: docs-adoc
menu: framework
---

Interceptors allow you to observe and modify requests and responses at various stages of the request lifecycle, as defined by the `interceptPoint` parameter of the `@RegisterPlugin` annotation.

The `Interceptor.handle(req, res)` method is invoked when `Interceptor.resolve(req, res)` returns `true`.

== The Interceptor Class

An `Interceptor` is comprised of a class implementing one of the `Interceptor` interfaces, such as `MongoInterceptor`, and annotated with `@RegisterPlugin`.

The crucial method is `handle(req, res)`, executed when `resolve(req, res)` returns `true`.

The `req` and `res` arguments allow you to retrieve and modify the content, query parameters, and headers of both the request and response objects.

The special interceptor interface, `WildcardInterceptor`, intercepts requests handled by any `Service`. Other interceptors can handle requests with matching types between the Service and the Interceptor:

- `WildcardInterceptor`: Intercepts requests handled by any service
- `ByteArrayInterceptor`: Intercepts requests handled by services implementing `ByteArrayService`
- `JsonInterceptor`: Intercepts requests handled by services implementing `JsonService`
- `BsonInterceptor`: Intercepts requests handled by services implementing `BsonService`
- `MongoInterceptor`: Intercepts requests handled by the `MongoService`
- `GraphQLInterceptor`: Intercepts GraphQL requests (available from v7.6.2)
- `ProxyInterceptor`: Intercepts proxied requests

NOTE: `MongoInterceptor` is particularly useful as it allows intercepting requests to the `MongoService`, adding logic to its data API. For instance, the following response interceptor removes the property `secret` from `GET /coll`.

[source,java]
----
@RegisterPlugin(name = "secretFilter",
    interceptPoint = InterceptPoint.RESPONSE,
    description = "removes the property 'secret' from GET /coll")
public class ReadOnlyPropFilter implements MongoInterceptor {
    @Override
    public void handle(MongoRequest request, MongoResponse response) throws Exception {
        if (response.getContent().isDocument()) {
            response.getContent().asDocument().remove("secret");
        } else if (request.getContent().isArray()) {
            response.getContent().asArray().stream()
                .map(doc -> doc.asDocument())
                .forEach(doc -> doc.remove("secret"));
        }
    }

    @Override
    public boolean resolve(MongoRequest request, MongoResponse response) {
        return request.isGet()
            && response.getContent() != null
            && "coll".equalsIgnoreCase(request.getCollectionName());
    }
}
----

TIP: Watch link:https://www.youtube.com/watch?v=GReteuiMUio&t=986s[Interceptors]

== @RegisterPlugin Annotation

All plugins must be annotated with `@RegisterPlugin` to:

- Allow RESTHeart to discover plugins' implementation classes in deployed JARs (see link:/docs/plugins/deploy[How to Deploy Plugins])
- Specify parameters such as the URI of a Service or the intercept point of an Interceptor.

An example follows:

[source,java]
----
@RegisterPlugin(name = "foo",
    description = "just an example service",
    defaultUri="/foo",      // optional, default /<service-name>
    secure=false,           // optional, default false
    enabledByDefault=false) // optional, default true
public class MyPlugin implements JsonService {
...
}
----

The following table describes the arguments of the annotation:

[options="header"]
[cols="1,3,1,1"]
|===
|param |description |mandatory |default value
|`name`
|the name of the Interceptor
|yes
|*none*
|`description`
|description of the Interceptor
|yes
|*none*
|`enabledByDefault`
|`true` to enable the plugin; can be overridden by the plugin configuration option `enabled`
|no
|`true`
|`interceptPoint`
|the intercept point: `REQUEST_BEFORE_EXCHANGE_INIT`, `REQUEST_BEFORE_AUTH`, `REQUEST_AFTER_AUTH`, `RESPONSE`, `RESPONSE_ASYNC`
|no
|`requiresContent`
|proxy interceptor
|Only used by Interceptors of proxied resources (the content is always available to Interceptor of Services) Set it to `true` to make available the content of the request (if interceptPoint is `REQUEST_BEFORE_AUTH` or `REQUEST_AFTER_AUTH`) or of the response (if interceptPoint is `RESPONSE` or `RESPONSE_ASYNC`)
|no
|`false`
|`priority`
|the execution priority (less is higher priority)
|no
|`10`
|===

== Transform the Request Content Format

Imagine you want to send a request to the `MongoService` using XML. You must transform the request content from XML to Bson because the `MongoService` expects the request to be in the latter format.

`Interceptors` at `REQUEST_BEFORE_EXCHANGE_INIT` can inspect and modify the request
before it is actually initialized.

IMPORTANT: Only `WildcardInterceptor` can use this intercept point.

The `Interceptor.handle(req, res)` receives the request as `UninitializedRequest`
and the response as `UninitializedResponse`.

It can set a custom initializer with `PluginUtils.attachCustomRequestInitializer()` or modify the raw request content (not yet parsed to the Service content type) using `Request.setRawContent()`.

The example link:https://github.com/SoftInstigate/restheart/tree/master/examples/protobuffer-contacts[protobuffer-contacts] demonstrates how to transform the request and response content to and from a different format than expected by a Service.