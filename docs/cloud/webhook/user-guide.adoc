---
title: Webhook Plugin - User Guide
layout: docs-adoc
menu: cloud
applies_to: cloud
---

== Accessing Webhook Management

Access webhook configuration from your service's *Plugins* tab. You can use the inline configuration for quick edits or click *Open Dedicated Page* for a full-screen interface with split panelsâ€”same functionality, different layouts.

The interface shows webhook configurations on the left and details/logs on the right with two tabs: *Details* for configuration and *Logs* for execution history.

== Configuration Fields

*Webhook Name*: Descriptive identifier like "Slack Order Alerts" or "Mailjet Welcome Email"

*Target URL*: HTTP endpoint receiving the webhook POST request (must be publicly accessible)

*Condition*: MongoDB-style predicate determining when to trigger

*Timeout*: Maximum response wait time in milliseconds (1000-30000, default 5000)

*Headers*: JSON object for authentication and custom headers

== Condition Predicates

=== Path Matching

[source]
----
path('/users')                    # Exact match
path-prefix('/data')              # Starts with /data
path-template('/users/{id}')      # Parameterized paths
path('/users') or path('/orders') # Multiple paths
----

=== HTTP Methods

[source]
----
method('POST')
method('POST') or method('PUT')
----

=== Response Status

[source]
----
response-code(201)
response-code(200) and path('/users')
----

=== Combining Conditions

[source]
----
path('/orders') and method('POST') and response-code(201)
path-prefix('/data') and (method('POST') or method('PUT'))
path-template('/users/{id}') and (method('PUT') or method('PATCH'))
----

== Payload Transformation

Enable transformation when target services require specific JSON formats. Uses Mustache templates with simple `{{variable}}` syntax.

=== Basic Example

[source,json]
----
{
  "user": "{{request.body.username}}",
  "timestamp": "{{timestamp}}",
  "action": "created"
}
----

=== Available Variables

*Service*: `{{service.id}}`, `{{timestamp}}`

*Request*: `{{request.method}}`, `{{request.path}}`, `{{request.body.fieldName}}`, `{{request.headers.Header-Name}}`

*Response*: `{{response.statusCode}}`, `{{response.body.fieldName}}`, `{{response.headers.Header-Name}}`

Use dot notation for nested fields: `{{request.body.customer.email}}`

=== Example Templates

*Slack Notification*:
[source,json]
----
{
  "text": "Alert from {{service.id}}",
  "blocks": [{
    "type": "section",
    "text": {
      "type": "mrkdwn",
      "text": "*Request on {{request.path}}*\n*Method:* {{request.method}}\n*Status:* {{response.statusCode}}"
    }
  }]
}
----

*Mailjet Email*:
[source,json]
----
{
  "Messages": [{
    "From": {
      "Email": "noreply@yourdomain.com",
      "Name": "Your App"
    },
    "To": [{
      "Email": "{{request.body.email}}",
      "Name": "{{request.body.name}}"
    }],
    "Subject": "Welcome!",
    "TextPart": "Hi {{request.body.name}}, welcome to our service!"
  }]
}
----

The interface includes a variable reference panel (click variables to insert) and example templates you can load and customize.

== Execution Logs

Select a webhook and switch to the *Logs* tab to view execution history. Each entry shows timestamp, status (success/failed/skipped), duration, and request details.

Click any entry to see:

*Summary*: Overall status and duration

*Incoming Request*: Method, path, headers, body

*Condition Evaluation*: Whether condition matched

*Transformation*: Input/output if enabled

*Outgoing Request*: What was sent to target

*Response*: Status, headers, body from target

Filter by status using the dropdown. Click *Refresh* to load latest executions. Click *Clear Logs* to delete old entries (also auto-deleted after 30 days).

== Recording

Click *Start Recording* to capture real requests for 60 seconds regardless of conditions. Review recorded logs to see actual request structures, helping you build accurate conditions and transformations.

== Testing

Always click *Test Webhook* before saving. This sends a sample request to your target URL and shows the result, verifying configuration before production use.

== Troubleshooting

*Webhook never triggers*: Use recording to capture actual requests, then verify your condition matches the paths and methods.

*Always skipped*: Condition doesn't match. Compare actual request paths in logs to your condition predicate.

*401 Unauthorized*: Check authentication headers match target service requirements.

*400 Bad Request*: Review transformation output in logs. Ensure required fields are present and match target API format.

*500 errors from target*: Target service issue. Check their status page or review your payload for problematic data.

*Timeout errors*: Increase timeout_ms value or verify target service responds promptly.

*Wrong transformation output*: Use recording to see actual field names. Check variable paths use correct dot notation.

== Best Practices

Use specific conditions to avoid triggering on every request. Start simple and add complexity incrementally. Test transformations with varied input data. Set realistic timeouts (5-10 seconds for most services). Use HTTPS target URLs. Send only necessary data using transformation. Review logs regularly to catch issues early.

== Multiple Webhooks

Create multiple webhooks per service with different conditions and targets. All matching webhooks execute in parallel. One webhook's failure doesn't affect others.

== Next Steps

See link:tutorials.html[Tutorials] for complete integration examples with Slack and email services, or check link:api-documentation.html[API Documentation] for programmatic access.
