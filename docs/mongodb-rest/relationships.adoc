---
title: Document Relationships
layout: docs-adoc
menu: mongodb
---

MongoDB is a document database without built-in join operations, but that doesn't mean your data can't have relationships. RESTHeart provides a convenient way to define and navigate relationships between documents, making it easier to model connected data.

=== Introduction to MongoDB Relationships

In MongoDB, documents can reference other documents in several ways:

* *Embedded documents* - nesting related data within a single document
* *Document references* - storing the ID of a related document as a field value
* *Array of references* - storing multiple related document IDs in an array

RESTHeart enhances MongoDB's reference approach by allowing you to declare existing relationships in your collections. Once declared, RESTHeart automatically adds hyperlinks to related documents in the representation.

[IMPORTANT]
====
Relationship links are only available in the HAL representation format. To see these links, add the query parameters `?rep=HAL&hal=f` to your requests.
====

=== Defining Relationships

Relationships are defined in the collection metadata using the `rels` property. This is an array of relationship objects that tell RESTHeart how documents in the collection are connected to other documents.

==== Relationship Definition Object

[source,json]
----
{
    "rel": "relationshipName",
    "type": "RELATIONSHIP_TYPE",
    "role": "ROLE_TYPE",
    "target-db": "targetDatabase",
    "target-coll": "targetCollection",
    "ref-field": "referenceField"
}
----

[cols="1,3,1", options="header"]
|===
|Property |Description |Required
|`rel` |The name of the relationship (used in the `_links` property) |Yes
|`type` |Relationship type: `ONE_TO_ONE`, `MANY_TO_ONE`, `ONE_TO_MANY`, or `MANY_TO_MANY` |Yes
|`role` |`OWNING` (reference field is in this document) or `INVERSE` (reference field is in the target document) |Yes
|`target-db` |Database containing the referenced documents |No (defaults to current database)
|`target-coll` |Collection containing the referenced documents |Yes
|`ref-field` |Field containing the reference ID(s) or JSON path expression |Yes
|===

==== Understanding Relationship Types

* `ONE_TO_ONE` - A document references exactly one other document (e.g., a person and their passport)
* `MANY_TO_ONE` - Many documents reference the same document (e.g., employees and their department)
* `ONE_TO_MANY` - A document references many other documents (e.g., a customer and their orders)
* `MANY_TO_MANY` - Many documents reference many other documents (e.g., students and courses)

==== Understanding Relationship Roles

* `OWNING` - The current document contains the reference field
* `INVERSE` - The target document contains the reference field

=== Example Relationship Patterns

==== Pattern 1: Document Tree (Parent-Child)

This pattern allows you to create hierarchical data where each document references its parent.

. Create a collection with a parent relationship:
+
[source,http]
----
PUT /categories HTTP/1.1
Content-Type: application/json

{
    "rels": [
        {
            "rel": "parent",
            "type": "MANY_TO_ONE",
            "role": "OWNING",
            "target-coll": "categories",
            "ref-field": "parentId"
        }
    ],
    "description": "Product categories organized in a tree"
}
----

. Create the root category:
+
[source,http]
----
PUT /categories/electronics HTTP/1.1
Content-Type: application/json

{
    "name": "Electronics",
    "description": "Electronic devices and accessories"
}
----

. Create child categories referencing the parent:
+
[source,http]
----
PUT /categories/smartphones HTTP/1.1
Content-Type: application/json

{
    "name": "Smartphones",
    "description": "Mobile phones with advanced features",
    "parentId": "electronics"
}
----
+
[source,http]
----
PUT /categories/laptops HTTP/1.1
Content-Type: application/json

{
    "name": "Laptops",
    "description": "Portable computers",
    "parentId": "electronics"
}
----

. Now when you request a child document with HAL representation:
+
[source,http]
----
GET /categories/smartphones?rep=HAL&hal=f HTTP/1.1
----
+
You'll get a response with a link to the parent:
+
[source,json]
----
{
    "_id": "smartphones",
    "name": "Smartphones",
    "description": "Mobile phones with advanced features",
    "parentId": "electronics",
    "_links": {
        "self": {
            "href": "/categories/smartphones"
        },
        "parent": {
            "href": "/categories/electronics"
        }
    }
}
----

==== Pattern 2: One-to-Many, Owner Side

In this pattern, a document owns references to multiple related documents. For example, a band owning references to its albums.

. Create the albums collection:
+
[source,http]
----
PUT /albums HTTP/1.1
Content-Type: application/json

{
    "description": "Music albums"
}
----

. Create the bands collection with a relationship to albums:
+
[source,http]
----
PUT /bands HTTP/1.1
Content-Type: application/json

{
    "rels": [
        {
            "rel": "albums",
            "type": "ONE_TO_MANY",
            "role": "OWNING",
            "target-coll": "albums",
            "ref-field": "albumIds"
        }
    ],
    "description": "Music bands and artists"
}
----

. Create some albums:
+
[source,http]
----
PUT /albums/album1 HTTP/1.1
Content-Type: application/json

{
    "title": "The Dark Side of the Moon",
    "year": 1973
}
----
+
[source,http]
----
PUT /albums/album2 HTTP/1.1
Content-Type: application/json

{
    "title": "Wish You Were Here",
    "year": 1975
}
----

. Create a band that references these albums:
+
[source,http]
----
PUT /bands/pinkfloyd HTTP/1.1
Content-Type: application/json

{
    "name": "Pink Floyd",
    "formed": 1965,
    "albumIds": ["album1", "album2"]
}
----

. When you request the band document with HAL representation:
+
[source,http]
----
GET /bands/pinkfloyd?rep=HAL&hal=f HTTP/1.1
----
+
You'll get a response with a link to query the albums:
+
[source,json]
----
{
    "_id": "pinkfloyd",
    "name": "Pink Floyd",
    "formed": 1965,
    "albumIds": ["album1", "album2"],
    "_links": {
        "self": {
            "href": "/bands/pinkfloyd"
        },
        "albums": {
            "href": "/albums?filter={'_id':{'$in':['album1','album2']}}"
        }
    }
}
----

==== Pattern 3: One-to-Many, Inverse Side

In this pattern, multiple documents reference a single document. For example, albums referencing their band.

. Create the bands collection:
+
[source,http]
----
PUT /bands HTTP/1.1
Content-Type: application/json

{
    "rels": [
        {
            "rel": "albums",
            "type": "ONE_TO_MANY",
            "role": "INVERSE",
            "target-coll": "albums",
            "ref-field": "bandId"
        }
    ],
    "description": "Music bands and artists"
}
----

. Create the albums collection:
+
[source,http]
----
PUT /albums HTTP/1.1
Content-Type: application/json

{
    "description": "Music albums with band references"
}
----

. Create a band:
+
[source,http]
----
PUT /bands/beatles HTTP/1.1
Content-Type: application/json

{
    "name": "The Beatles",
    "formed": 1960
}
----

. Create albums that reference the band:
+
[source,http]
----
PUT /albums/abbey-road HTTP/1.1
Content-Type: application/json

{
    "title": "Abbey Road",
    "year": 1969,
    "bandId": "beatles"
}
----
+
[source,http]
----
PUT /albums/revolver HTTP/1.1
Content-Type: application/json

{
    "title": "Revolver",
    "year": 1966,
    "bandId": "beatles"
}
----

. When you request the band document with HAL representation:
+
[source,http]
----
GET /bands/beatles?rep=HAL&hal=f HTTP/1.1
----
+
You'll get a response with a link to query all the band's albums:
+
[source,json]
----
{
    "_id": "beatles",
    "name": "The Beatles",
    "formed": 1960,
    "_links": {
        "self": {
            "href": "/bands/beatles"
        },
        "albums": {
            "href": "/albums?filter={'bandId':'beatles'}"
        }
    }
}
----

=== Advanced Relationship Features

==== Reference Fields with JSON Path Expressions

For references stored in nested documents, use a JSON path expression starting with `$`:

[source,json]
----
{
    "rel": "author",
    "type": "MANY_TO_ONE",
    "role": "OWNING",
    "target-coll": "users",
    "ref-field": "$.metadata.authorId"
}
----

This will match a document structure like:

[source,json]
----
{
    "title": "My Article",
    "content": "...",
    "metadata": {
        "authorId": "user123",
        "publishDate": "2023-05-15"
    }
}
----

==== Cross-Database Relationships

To reference documents in another database, specify the `target-db` property:

[source,json]
----
{
    "rel": "products",
    "type": "ONE_TO_MANY",
    "role": "OWNING",
    "target-db": "inventory",
    "target-coll": "products",
    "ref-field": "productIds"
}
----

=== Best Practices

. *Choose the right relationship type* - Consider the cardinality of your data relationships carefully
. *Use descriptive relationship names* - Name relationships in a way that clearly describes their purpose
. *Keep consistency* - For bidirectional relationships, ensure that both sides are properly defined
. *Consider performance* - For very large collections, be mindful of the performance impact of relationships
. *Document your schema* - Keep documentation of your data model including all relationships

=== Limitations

. Relationships are metadata only - they don't enforce referential integrity
. Links are only available in HAL representation format
. Following multiple relationship links requires multiple requests
