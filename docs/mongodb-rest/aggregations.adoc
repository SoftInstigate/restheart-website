---
title: Aggregations
layout: docs-adoc
menu: mongodb
---

> Aggregations operations process data records and return computed results. Aggregation operations group values from multiple documents together, and can perform a variety of operations on the grouped data to return a single result.

The RESTHeart API provides powerful aggregation capabilities to developers, including the ability to run both aggregation pipelines and map reduce functions using just a GET request.

To execute an aggregation query, simply send a GET request to `/coll/_aggrs/<aggregation-uri>` with the appropriate parameters!

NOTE: Only inline output type is supported - meaning that no results are written directly to the database. However, if you wish to have results written to the database, then link:(#materialized-views)[Materialized Views] is the solution for you.

Ã¹In both cases only _inline_ output type is supported, i.e. no result is directly
written to the DB server unless the link:#materialized-views[Materialized Views] are used.

== Aggregation definition

NOTE: In RESTHeart, not only documents but also dbs and collections have
properties. Some properties are metadata, i.e. they have a special
meaning for RESTheart that influences its behavior.


You can define aggregation by setting the aggrs collection metadata property via a `PATCH /coll` request. Here is an example of how to structure the request body:

[source,http]
----
PATCH /coll/_meta HTTP/1.1

{
    "aggrs": [
        { <aggregation_1> },
        { <aggregation_2> },
        ...,
        { <aggregation_n> }
    ]
}
----

The _aggregation definition objects_ have the following format:

[source,json]
----
{
    "type":"pipeline",
    "uri": "<uri>",
    "stages": [
        "<stage_1>",
        "<stage_2>",
        "..."
    ],
    "allowDiskUse": true
}
----

[options="header"]
[cols="1,5,1"]
|===
|Property |Description |Mandatory
|type
|for aggregation pipeline operations is "pipeline"
|yes
|uri
|specifies the URI when the operation is bound under the path `/<collection>/_aggrs`
|yes
|stages
|the MongoDB aggregation pipeline stages. For more information refer to link:https://docs.mongodb.org/manual/core/aggregation-pipeline[Aggregation Pipeline] on MongoDb documentation.
|yes
|===

== Example

The following request updates set an aggregation pipeline bound at `/coll/_aggrs/example-pipeline`

[source,http]
----
PATCH /coll HTTP/1.1

{
  "aggrs": [
    {
      "stages": [
        { "$match": { "name": { "$var": "name" } } },
        { "$group": { "_id": "$name", "avg_age": { "$avg": "$age" } } }
      ],
      "type": "pipeline",
      "uri": "example-pipeline"
    }
  ]
}
----

== Parametric aggregations

Using variables to define parameters in an aggregation allows you to include dynamic queries and create a more customized output. This can help to make the query much more specific and efficient when retrieving data from the database.

=== Variables

In aggregation definitions, the special operator `{"$var": "name" }` can be used to define parametric aggregations.

On the other side, the query parameter `?avars` allows passing variables to aggregations as in `?avars={"name":"Bob"}`

NOTE: The value of a variable can be any valid JSON. The following query parameter passes two variables, a string and an object: `?avars={ "name": "Bob", "obj": {"a": { "json": "object" }} }`

The previous example aggregation use a variable named `n`. If the variable is not passed via the `?avars` qparam, the request fails.

[source,http]
----
GET /coll/_aggrs/example-pipeline HTTP/1.1

HTTP/1.1 400 Bad Request

{
    "http status code": 400,
    "http status description": "Bad Request",
    "message": "error executing aggreation pipeline: variable n not bound"
}
----

Passing the variable `n`, the request succeeds:

[source,http]
----
GET /coll/_aggrs/example-pipeline?avars={"name":"Bob"} HTTP/1.1

HTTP/1.1 200 OK

(response content omitted)
----

=== Variables with default values

NOTE: Variables with default values are available from RESTHeart 7.3

You can specify a default variable for an aggregation variable. When making the request, if you don't pass in a value for it with `?avar?` query parameter, the specified default value will be used instead.

To define a variable with a default value use the syntax `{"$var": [ "name", "default-value" ] }`.

NOTE: The default value can be any json as in `{"$var": [ "s", {"name":1} ] }` where the default value is `{"name":1}`

An example aggregation that uses the variable `s` with a default value in the `$sort` stage follows:

[source,json]
----
{
  "aggrs": [
    {
        "uri": "sort-with-default-example",
        "type": "pipeline",
        "stages": [
            { "$sort": { "$var": [ "s", { "name": 1 } ] } }
        ]
    }
  ]
}
----

=== Predefined variables

The following predefined variables can be used in the aggregation definition:

[options="header"]
[cols="1,3"]
|===
|variable|description
|`@user`
|the user object (excluding the password), e.g. `@user._id` (for users defined in MongoDB by `MongoRealmAuthenticator`) or `@user.userid` (for users defined in acl.yml by `FileRealmAuthenticator`)
|`@mongoPermissions`
|the `MongoPermissions` object, e.g. `@mongoPermissions.readFilter`
|`@page`
|the value of the `page` query parameter
|`@pagesize`
|the value of the `pagesize` query parameter
|`@skip`
|to be used in `$skip` stage, equals to `(page-1)*pagesize`
|`@limit`
|to be used in `$limit` stage, equals to the value of the `pagesize` query parameter
|===

=== Handling paging in aggregations

Paging must be handled explicitly by the aggregation-

For example, the following defines the aggregation `/aggrs/paging` that uses the `@skip` and `@limit` variables. As a result, the request `GET /coll/_aggrs/paging?page=3&pagesize=25` skips 50 documents, returning the following 25 documents.

```json
{
  "aggrs": [
    {
      "uri": "paging",
      "type": "pipeline",
      "stages": [
        { "$skip": { "$var": "@skip" } },
        { "$limit": { "$var": "@limit" } }
      ]
    }
  ]
}
```

=== Optional stages

NOTE: Optional stages are available from RESTHeart 7.3

A pipeline can include optional stages, which only get included if certain variables are set through the use of a `?avar` query parameter.

Use the operator `$ifvar` to define an optional stage:

With one required variable use `{ "$ifvar": [ "required-variable", <stage> ] }`. Example:

[source,json]
----
{
    "uri": "by-name",
    "type": "pipeline",
    "stages": [
        { "$match": { "name": "foo" } },
        { "$ifvar": [ "s", { "$sort": { "$var": "s" } } ] }
    ]
}
----

To specify more than one required variable, use `{ "$ifvar": [ [ <required-variables> ], <stage> }`. Example:

[source,json]
----
{
    "uri": "by-name",
    "type": "pipeline",
    "stages": [
        { "$match": { "name": "foo" } },
        { "$ifvar": [ ["a", "b" ] , { "$match": { "foo": { "$var": "a" }, "bar": { "$var": "b" } } } ] }
    ]
}
----

It is also possible to specify an _else_ stage, i.e. an alternative stage that is included in the aggregation, if the required variables are not passed via the `?avar` query parameter.

To specify an _else_ stage, use  `{ "$ifvar": [ <required-variable> | [ <required-variables> ], <stage>, <else-stage> }`. Example:

[source,json]
----
{
    "uri": "by-name",
    "type": "pipeline",
    "stages": [
        { "$match": { "name": "foo" } },
        { "$ifvar": [ ["a", "b" ],
            { "$match": { "foo": { "$var": "a" }, "bar": { "$var": "b" } } },
            { "$match": { "foo": 1, "bar": 2 } } ] }
    ]
}
----

== Materialized Views

The `$merge` stage for the pipelines delivers the ability to create collections based on an aggregation and update those created collections efficiently, i.e. it just updates the generated results collection rather than rebuild it completely (like it would with the `$out` stage).

It's as simple as adding `$merge` as the last stage of the pipeline.

The following example defines the aggregation `/coll/_aggrs/age-by-gender` that computes average ages grouping data by gender. `$merge` is used as the last stage of the pipeline to write computed data to the `avgAgeByGender` collection.

[source,http]
----
PUT /coll HTTP/1.1

{ "aggrs" : [
    { "stages" : [
        { "$group" : { "_id" : "$gender", "avg_age" : { "$avg" : "$age" } } },
        { "$merge": { "into": "avgAgeByGender" } }
      ],
      "type" : "pipeline",
      "uri" : "age-by-gender"
    }
  ]
}
----

Executing the aggregation request returns no data, but thanks to the `$merge` stage, the new collection `avgAgeByGender` gets created.


[source,http]
----
GET /coll/_aggrs/avg-by-city HTTP/1.1

HTTP/1.1 200 OK
[]
----

[source,http]
----
GET /avgAgeByGender HTTP/1.1

HTTP/1.1 200 OK
[
    { "_id": "male", "avg_age": 34.5 }
    { "_id": "female", "avg_age": 35.6 }
]
----


== Security considerations

By default RESTHeart makes sure that the aggregation variables passed as query parameters don't include MongoDB operators.

This behavior is required to protect data from undesirable malicious query injection.

Even though is highly discouraged, is possible to disable this check by editing the following property in the `restheart.yml` configuration file.

[source,yml]
----
# Check if aggregation variables use operators. https://restheart.org/docs/mongodb-rest/aggregations/#security-considerations
mongo:
    aggregation-check-operators: true
----

== Transaction Support

Aggregations are executed in the transaction scope if specified via the `sid` and `txn` query parameters.

For more information on how to create a transaction scope refer to [transactions](/docs/mongodb-rest/transactions) doc page.

== Map-Reduce

WARNING: map reduce are deprecated. Use aggregation pipeline instead. See link:https://www.mongodb.com/docs/manual/core/map-reduce/[Map-Reduce] in MongoDb documentation.

[source,json]
----
{
    "type": "mapReduce",
    "uri": "<uri>",
    "map": "<map_function>",
    "reduce": "<reduce_function>",
    "query": "<query>"
}
----

<div class="table-responsive">
<table class="ts">
<thead>
<tr class="header">
<th>Property</th>
<th>Description</th>
<th class="text-center">Mandatory</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>type</strong></td>
<td>for aggregation pipeline operations is &quot;mapReduce&quot;</td>
<td class="text-center">yes</td>
</tr>
<tr class="even">
<td><strong>uri</strong></td>
<td>specifies the URI when the operation is bound under /&lt;db&gt;/&lt;collection&gt;/_aggrs path.</td>
<td class="text-center">yes</td>
</tr>
<tr class="odd">
<td><strong>map</strong></td>
<td><p>the map function</p>
<p>For more information refer to <a href="https://docs.mongodb.org/manual/core/map-reduce/" class="uri">https://docs.mongodb.org/manual/core/map-reduce/</a></p></td>
<td class="text-center">yes</td>
</tr>
<tr class="even">
<td>reduce</td>
<td>the reduce function</td>
<td class="text-center">yes</td>
</tr>
<tr class="odd">
<td>query</td>
<td>the filter query</td>
<td class="text-center">no</td>
</tr>
</tbody>
</table>
</div>

=== Example

The following request update the collection metadata defining a map reduce operation bound at `/coll/_aggrs/example-mapreduce`

[source,http]
----
PUT /coll HTTP/1.1

{
  "aggrs": [
    {
      "map": "function() { emit(this.name, this.age) }",
      "query": { "name": { "$var": "n" } },
      "reduce": "function(key, values) { return Array.avg(values) }",
      "type": "mapReduce",
      "uri": "example-mapreduce"
    }
  ]
}
----

== Variables in map reduce functions

Variables are passed also to *map* and *reduce* javascript functions
where the variable `$vars` can be used. For instance:

[source,http]
----
PATCH /coll HTTP/1.1

{ "aggrs" : [
    {
      "map" : "function() { var minage = JSON.parse($vars).minage; if (this.age > minage ) { emit(this.name, this.age); }; }",
      "reduce" : "function(key, values) { return Array.avg(values) } }",
      "type" : "mapReduce",
      "uri" : "example-mapreduce"
    }
  ]
}

HTTP/1.1 200 Ok
----

Note the _map_ function; `JSON.parse($vars)` allows to access the
variables passed with the query parameter `avars`

[source,js]
----
function() {
 var minage = JSON.parse($vars).minage;// <-- here we get minage from avars qparam
 if (this.age > minage ) { emit(this.name, this.age); }
};
----